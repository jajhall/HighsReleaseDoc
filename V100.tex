\documentclass[a4paper,12pt,twoside]{article}
\usepackage{xspace}
\usepackage{url}
\usepackage{relsize}
\usepackage{calc}
\usepackage{dimensions}
\usepackage{rotating}
\usepackage{colortbl}
\usepackage{algpseudocode}
\usepackage{algorithm} 
\usepackage{underscore} 

\input Alias

\title{
\HiGHS Version 1.0.0}
\date{\today}
\author{\HighsEmail}

\flushbottom
\renewcommand{\familydefault}{\sfdefault}

\begin{document}

%\pagenumbering{roman}
\maketitle
\tableofcontents

\section{Introduction}
This document defines what \HiGHS can do, and how it can be run and
controlled externally. Mathematically, this document assumes no
more than familiarity with the definition of a linear programming (LP)
problem, and the fact that they can be solved with either the simplex
algorithm or interior point methods. Although \HiGHS can solve
mixed-integer programming (MIP) and quadratic programming (QP)
problems, users who have no interest in doing so can ingore references
to these problem classes.

The following is a list of \HiGHS-related information not covered in this document and, if available, where it may be found.
\begin{itemize}
  \item How to download and build \HiGHS. See \HighsTextURL.
  \item How to call \HiGHS from languages other than \Cpp and \C. See \HighsTextURL.
  \item How \HiGHS is engineered internally. This is not currently documented byond the source code.
  \item The theory underlying the optimzation methods used by
    \HiGHS. See (in particular) the work on high performance dual
    simplex by Huangfu and Hall~\cite{HuHa13}, and on the interior
    point method by Schork and Gondzio~\cite{ScGo20}.
\end{itemize}

\subsection{Overview}

Sections~\ref{sect:ModelDefinition}--\ref{sect:Options} set out what
\HiGHS can do, the methods by which this is achieved, and the
parameters that control them. This is done by introducing the data
structures of \HiGHS that are used in the \Cpp interface, the methods
in the \Cpp interface, and the corresponding methods in the \C
interface. 

Models are either passed to \HiGHS directly, or read from data
files. The definition of the \HiGHS model data structure is set out in
Section~\ref{sect:ModelDefinition}, together with the methods for
model input and output in the \Cpp and \C
interfaces. Section~\ref{sect:ModelSolution} describes how \HiGHS is
used to solve models, and how the resulting solution data may be
obtained. Models may be modified in ways set out in
Section~\ref{sect:ModelModification}, and other functionality
available within \HiGHS is covered in
Section~\ref{sect:OtherFeatures}.

The parameters that control how \HiGHS runs are referred to option
values. Their definition, default values and the means of modifying
them are defined in Section~\ref{sect:Options}.

\subsection{Creating a \Highs{} instance}
In \Cpp, an instance of the \Highs{} class named (for example) \HighsInstance{} is created thus
\begin{tabbing}
\ \ \Highs{} \HighsInstance;
\end{tabbing}
This requires the inclusion of the header file \HighsH. In \C, an
instance of \Highs{} is created and destroyed using the methods defined
in Table~\ref{tab:CHighsCreateDestroy}, so an instance named (for
example) \HighsInstance{} is created and destroyed thus
%
\begin{tabbing}
\ \ \code{void* highs = \CHighsCreate;}\\
\ \ \code{Highs\_destroy(highs);}
\end{tabbing}
For all other methods in the \C interface, the first argument is the void pointer \HighsInstance.

\begin{table}[ht]
%  \begin{mdframed}
    \leftline{
      \begin{tabular}{p{15cm}}
        \CHighsCreateDef \\
        \CHighsDestroyDef
    \end{tabular}}
    \caption{Methods in the \C interface to create and destroy a \Highs{} instance}\label{tab:CHighsCreateDestroy}
%\end{mdframed}
\end{table}

\subsection{Long integers}
\input HighsInt

\subsection{Return values}
Most methods in the \Cpp and \C interfaces return a status to indicate
the success of the call. Those that do not are methods where model or
solution information is returned (and success can be assumed). The
type of the return status is \EnumClass{} \HighsStatus, with members
listed in Table~\ref{tab:HighsStatusEnumClass}, where the integer
value given is the cast used in the \C interface.

\input TableHighsStatusEnumClass

\subsection{Terminology}
The word ``vector'' is used to refer to the mathematical object in the
definition of a model. Within code, the corresponding data structure
is referred to as an array. The model within \HiGHS that has been
passed, read or built, and possibly modified, is referred to as the
``incumbent model''.

\subsection{Style}

For the \Cpp interface and, to an increasing extent internally, \HiGHS
now conforms to the Google \Cpp style guide~\cite{GoogleStyleGuide}.

\section{Model definition}\label{sect:ModelDefinition}
Models in \HiGHS are defined as an instance of the \HighsModel{}
class. This consists of one instance of the \HighsLp{} class,
and one instance of the \HighsHessian{} class. Communication of models
to and from \HiGHS is possible via instances of the \HighsLp{} or
\HighsModel{} class. In the \C and other interfaces, communication
of models is via scalar values and addresses of arrays.

\subsection{The \HighsLp{} class}\label{sect:HighsLp}

The \HighsLp{} class allows LP and MIP problems of the form
$$
\begin{array}{rl}
  \mathrm{minimize/maximize}&f+\bfc^T\bfx\\
  \mathrm{subject~to}&\bfL\le A\bfx\le \bfU\\
    &\bfl\le\bfx\le\bfu\\
  &\{x_i: i\in\SetI\}\in\Z
  \end{array}
$$
%
to be defined, and its members are defined in
Table~\ref{tab:HighsLp}. Since \HiGHS is written in \Cpp and \C, all
indexing begins from zero.

\begin{table}[ht]
\leftline{
  \begin{tabular}{|l|l|p{8cm}|}\hline
Type&Name&Description\\\hline
\HighsInt&\NumCol&Number of columns (variables) $\bfx$ in the model\\
\HighsInt&\NumRow&Number of rows (constraints) in the model\\
\ObjSense&\Sense&Sense of the objective: minimize or maximize\\
\Double&\Offset&Constant term $f$ in the objective function\\
\VectorDouble&\ColCost&Cost (gradient) vector $\bfc$ in the objective function\\
\VectorDouble&\ColLower&Lower bounds $\bfl$ on the columns\\
\VectorDouble&\ColUpper&Upper bounds $\bfu$ on the columns\\
\VectorDouble&\RowLower&Lower bounds $\bfL$ on the rows\\
\VectorDouble&\RowUpper&Upper bounds $\bfU$ on the rows\\
\MatrixOrientation&\Orientation&Orientation of the constraint matrix\\
\VectorHighsInt&\Astart&Start of each vector of $A$ in the compressed sparse storage\\
\VectorHighsInt&\Aindex&Indices of each vector of $A$ in the compressed sparse storage\\
\VectorDouble&\Avalue&Values of each vector of $A$ in the compressed sparse storage\\
\String&\ModelName&The name of the model\\
\VectorString&\ColName&The names of the columns\\
\VectorString&\RowName&The names of the rows\\
\VectorHighsVarType&\Integrality&The set $\SetI$ of integrality restrictions on columns\\\hline
  \end{tabular}}
\caption{\HighsLp{} class members}\label{tab:HighsLp}
\end{table}

Three members of the \HighsLp{} class (\Orientation, \Sense{} and
\Integrality) are of types particular to \HiGHS. They are all
\EnumClass, with members listed in Table~\ref{tab:HighsLpEnumClass},
where the integer value given is the cast used in the \C interface.

\begin{table}[ht]
  \leftline{
    \begin{tabular}{|l|r|p{6cm}|}\hline
      Name&Integer&Description\\\hline
      \MatrixOrientationNone&0&Undefined matrix orientation\\
      \MatrixOrientationColwise&1&Column-wise matrix orientation\\
      \MatrixOrientationRowwise&2&Row-wise matrix orientation\\\hline
      \ObjSenseMinimize&1&Optimization sense is minimize\\
      \ObjSenseMaximize&-1&Optimization sense is maximize\\\hline
      \HighsVarTypeContinuous&0&Variable can take continuous values\\
      \HighsVarTypeInteger&1&Variable must take integer values\\\hline
  \end{tabular}}
  \caption{The \EnumClass{} type names for \HighsLp{} class members}\label{tab:HighsLpEnumClass}
\end{table}
 
\subsubsection{Objective function}
The sense of the objective (minimize or maximize) is defined by the
value of the \Sense{} member of the \HighsLp{} class. This is of type
\ObjSense, an \EnumClass{} whose names are given in
Table~\ref{tab:HighsLpEnumClass}. When a \HighsLp{} instance is created,
\Sense is set to \ObjSenseMinimize{} so, unless changed, the objective
is minimized. In the \C interface, an \HighsInt{} parameter indicates
whether the matrix is to be minimized or maximized according to the
integer values in Table~\ref{tab:HighsLpEnumClass}.

\subsubsection{Constraint matrix}
The constraint matrix $A$ is held using compressed sparse
storage. Users unfamiliar with this format should consult
Wikipedia~\cite{WikiSparseMatrix}. Since solvers generally access the
constraint matrix column-wise, this was originally the only
orientation permitted by \HiGHS. However, it is often preferable for
modelling interfaces and users to specify the constraint matrix
row-wise. The \Orientation{} member of the \HighsLp{} class is used to
specify whether the matrix is held row-wise or column-wise. When a
\HighsLp{} instance is created, the orientation is indicated as
undefined by being set to \MatrixOrientationNone. If the orientation
is not set to either \MatrixOrientationColwise{} or
\MatrixOrientationRowwise, \HiGHS returns an error. In the \C
interface, an \HighsInt{} parameter indicates whether the matrix is
row-wise or column-wise according to the integer values in
Table~\ref{tab:HighsLpEnumClass}.

If the constraint matrix $A$ is held column-wise (row-wise) then the
size of \Astart{} must be at least \NumColPone{} (\NumRowPone), the
zero'th entry of \Astart{} must be zero, and entry \NumCol{} (\NumRow) is
the number of entries in the arrays \Aindex{} and \Avalue. Other
requirements are discussed in
Section~\ref{sect:ConstraintMatrixValidation}.

\subsubsection{Names}
When populating an instance of the \HighsLp{} class, no name data
needs to be supplied, and name data cannot be supplied via the \C
interface. The \ModelName{} member of the \HighsLp{} class is the
name of the model, and is used occasionally in logging output. By
default it is an empty string. If the model is read from a data file,
then \ModelName{} is the name of the file (less its extension). The
\ColName{} and \RowName{} members of the \HighsLp{} class are, by
default, of zero size. If the model is read from an MPS data file,
then \ColName{} and \RowName{} contain its column and row names. If names
are available they are printed when \HiGHS writes the model or
solution.

\subsubsection{Integrality}
The \Integrality{} member of the \HighsLp{} class indicates which
variables (if any) must take integer values. If this member is of zero
size, or if all its entries are \HighsVarTypeContinuous, the set
$\SetI$ is interpreted as being empty, so the instance is interpreted
as being an LP. If entries of \Integrality{} are \HighsVarTypeInteger{}
then, by default, the \HiGHS MIP solver will be used to find the
optimal integer values of the corresponding variables. In the \C
interface, an \HighsInt{} indicates whether a particular variable is
continuous or must take an integer value according to the integer
values in Table~\ref{tab:HighsLpEnumClass}.

\subsection{The \HighsHessian{} class}\label{sect:HighsHessian}
The \HighsHessian{} class allows the \HighsModel{} class to represent the
Hessian matrix of the quadratic term in the objective function that
distinguishes QP problems from LP problems. The representation of the
Hessian matrix is column-wise, and the \HighsHessian{} class members are
defined in Table~\ref{tab:HighsHessian}.

\begin{table}[ht]
\leftline{
  \begin{tabular}{|l|l|p{11cm}|}\hline
Type&Name&Description\\\hline
\HighsInt&\Qdim&Number of columns in the Hessian matrix\\
\VectorHighsInt&\Qstart&Start of each column in the compressed sparse column storage\\
\VectorHighsInt&\Qindex&Indices of each column in the compressed sparse column storage\\
\VectorDouble&\Qvalue&Values of each column in the compressed sparse column storage\\\hline
  \end{tabular}}
\caption{\HighsHessian{} class members}\label{tab:HighsHessian}
\end{table}

If a \HighsHessian{} instance has a positive value for \Qdim, and the
number of nonzeros in $Q$ is positive, then \Qdim must be equal to
\NumCol. As with the column-wise constraint matrix, the size of
\Qstart must be at least \QdimPone, the zero'th entry of \Qstart must
be zero, and entry \Qdim is the number of entries in the arrays
\Qindex and \Qvalue. Other requirements are discussed in
Section~\ref{sect:HessianMatrixValidation}.

\subsection{Model validation}\label{sect:ModelValidation}

When \HiGHS obtains a new model, it is validated for correctness and
extreme data values. Control of the latter is determined by option
values.

\subsubsection{Cost validation}\label{sect:CostValidation}

In \Cpp, if the size of \ColCost{} is less than \NumCol{} then \HiGHS
will return an error. Any entries found to be greater than the
\HighsOptions{} value \InfiniteCost{} in absolute value will cause
\HiGHS to return with \inred{a warning or an error}.


\subsubsection{Bound validation}\label{sect:BoundValidation}

In \Cpp, if the size of \ColLower{} or \ColUpper{} is less than \NumCol,
or if the size of \RowLower{} or \RowUpper{} is less than \NumRow, then
\HiGHS will return an error. Any lower bound found to be greater than
or equal to the \HighsOptions{} value \InfiniteBound, or any upper bound found to be less than
or equal to -\InfiniteBound, will cause \HiGHS to return with an error.

Bounds that are inconsistent due to the lower bound exceeding the
upper bound are permitted in \HiGHS but, when found, a warning message
will be issued. If \HiGHS is asked to solve a model with inconsistent
bounds, it will identify it as being infeasible.

Any lower bounds found to be less than or equal to -\InfiniteBound{}
will be ignored (treated as if they were negative infinity).  Any
upper bounds found to be greater than or equal to \InfiniteBound{} will
be ignored (treated as if they were positive infinity). \HiGHS will
report the number of bounds ignored in this way.

\subsubsection{Constraint matrix validation}\label{sect:ConstraintMatrixValidation}

There is considerable scope for errors when defining a matrix in
compressed vector form. Thus, \HiGHS validates any such data supplied
to it. The zero'th entry of the \Astart{} array must be zero, and
entries must increase monotonically. This will not be strict if the
matrix contains zero vectors. The \Aindex{} entries corresponding to a
particular vector must be non-negative, must not be greater than or
equal to the (full) vector dimension, and there must be no duplicate
entries. If the data fails to satisfy any of these conditions, \HiGHS
will return an error.

There are limits on the minimum and maximum absolute values in the
constraint matrix that \HiGHS will use. These limits are \HighsOptions{}
values \SmallMatrixValue{} and \LargeMatrixValue. Any entries below
\SmallMatrixValue{} in absolute value are ignored (with a warning) but
entries found to be greater than \LargeMatrixValue{} in absolute value
will cause \HiGHS to return with an error.

\subsubsection{Hessian matrix validation}\label{sect:HessianMatrixValidation}

An instance of the \HighsHessian{} class is validated for illegal
indexing in the same way as the constraint matrix. To discuss the
interpretation of the values in the instance, let $G$ be the
corresponding matrix. \HiGHS determines the matrix
$Q=\frac{1}{2}(G+G^T)$ and assesses its values the same way as the
constraint matrix, using the same option values for small and large
entries. If $Q$ is identically zero, then the \HighsHessian{}
instance is ignored, so the model will be solved as an LP. Otherwise,
$Q$ will be used as the quadratic term in the objective function.

As well as guaranteeing that the QP solver operates with a symmetric
Hessian matrix, this allows flexibility in the definition of the
Hessian matrix. If the original \HighsHessian{} instance
represents an entire symmetric matrix then, clearly, $Q=G$. However,
it may be convenient to for $G$ to be only the strictly upper
(equivalently lower) triangular portion of the Hessian, in which case
its strictly off-diagonal entries must be double the value in the
entire symmetric matrix.

The \HiGHS QP solver is for strictly convex problems: those with
positive definite Hessian. It will return with an error if it
identifies non-convexity. Since an {\em a priori\/} test of strict
convexity is a significant overhead, the only convexity test that is
performed is a check that all the diagonal entries of $Q$ are at least
\SmallMatrixValue.

\subsection{Methods}\label{sect:ModelDefinitionMethods}
In \Cpp, the model is passed to \HiGHS by creating an instance of the
\HighsModel{} class (or using a \HighsLp{} instance if the model of
interest is only an LP or MIP), populating its data, and passing it to
\HiGHS using \HighsPassModelGeneric as defined in
Table~\ref{tab:HighsPassModel}.

The forms of the argument to \HighsPassModelGeneric are defined so that
maximum memory efficiency can be achieved by passing the \HighsModel{}
or \HighsLp{} instance via \code{std::move}. For example, suppose that
the user's \HighsModel{} instance is called \code{model}. Calling
\code{passModel(std::move(model))} ensures that the array content of
the user's \HighsModel{} instance is moved to the \HighsModel{} instance
of the incumbent model in \Highs without creating an additional copy
at any stage. A consequence of this approach is that, on return from
\HighsPassModelGeneric, the user's \HighsModel{} instance has no array
content.

In the \C interface, the components of a \HighsModel{} or \HighsLp{}
instance are passed as indivdual scalars or pointers. The methods for
an LP, MIP or general model are defined in
Table~\ref{tab:CHighsPassModel}, where the parameter names are
arbitrary. However, for comparison, the names of the corresponding
class members are used.

\begin{table}[ht]
\leftline{
  \begin{tabular}{p{15cm}}
    \HighsPassModelModelDef \\
    \HighsPassModelLpDef 
  \end{tabular}}
\caption{Passing a \HighsModel{} or \HighsLp{} to \HiGHS in \Cpp}\label{tab:HighsPassModel}
\end{table}

\input TableCHighsPassModel

\section{Model solution}\label{sect:ModelSolution}
When the incumbent model is solved, the solution data that is
available from \HiGHS comes from four sources: the model status, a set
of scalar information values, the solution of the model and the status
of each variable and constraint.

\subsection{The model status}
When the incumbent model is solved, \HiGHS will identify a model
status. In \Cpp this value is taken from an \code{enum class}
\HighsModelStatus, whose entries are listed in
Table~\ref{tab:HighsModelStatus}. The corresponding integer values
used in the \C interface are also listed.

\begin{table}[ht]
\leftline{
  \begin{tabular}{|r|l|p{10cm}|}\hline
Integer&\HighsModelStatus&Description\\\hline
0&\code{kNotset}&Not set\\
1&\code{kLoadError}&Error loading the model\\
2&\code{kModelError}&Error in the model definition\\
3&\code{kPresolveError}&Error presolving the model\\
4&\code{kSolveError}&Error solving the model\\
5&\code{kPostsolveError}&Error postsolving the model\\
6&\code{kModelEmpty}&Model is empty\\
7&\code{kOptimal}&Model solution is optimal\\
8&\code{kInfeasible}&Model is (primal) infeasible \\
9&\code{kUnboundedOrInfeasible}&Model is (primal) unbounded or infeasible\\
10&\code{kUnbounded}&Model is (primal) unbounded\\
11&\code{kObjectiveBound}&Any optimal objective is at least a given bound \\
12&\code{kObjectiveTarget}&There is a feasible solution with at least a given target value \\
13&\code{kTimeLimit}&The solution time limit has been reached\\
14&\code{kIterationLimit}&The solution iteration limit has been reached\\
15&\code{kUnknown}&The model status is unknown\\\hline
  \end{tabular}}
\caption{Model status values}\label{tab:HighsModelStatus}
\end{table}

\subsection{Scalar information}
Scalar information about the solution of the model is held by \HiGHS
in an instance of the \HighsInfo{} class. The members of this class are
listed in Table~\ref{tab:HighsInfo}. The truth of \HighsInfoValid{}
indicates whether the values of the remaining members are valid. In
the \Cpp interface, a \Const{} reference to this instance of the \HighsInfo{}
class is available. Values of individual members can also be obtained,
and this is how they are in the \C interface.

The values of \HighsInfoPrimalSolutionStatus{} and
\HighsInfoDualSolutionStatus{} indicate the nature of the solution
values that are available. Valid values for the primal or dual
infeasiblility data are naturally non-negative. Thus a negative value
indicates that the data are not available.

Methods in ihe \Cpp interface allows values of individual members to
be obtained, and it is via correponding methods in the \C interface
that these information values are obtained.

\begin{table}[ht]
\leftline{
  \begin{tabular}{|l|l|p{10cm}|}\hline
Type&Name&Description\\\hline
\Bool & \HighsInfoValid &Validity of the data in the class instance\\
\LongInt & \HighsInfoMipNodeCount &Number of MIP nodes created\\
\HighsInt & \HighsInfoSimplexIterationCount &Cumulative number of simplex iterations performed\\
\HighsInt & \HighsInfoIpmIterationCount &Cumulative number of interior point iterations performed\\
\HighsInt & \HighsInfoCrossoverIterationCount &Cumulative number of crossover iterations performed\\
\HighsInt & \HighsInfoQpIterationCount &Cumulative number of QP solver iterations performed\\
\HighsInt & \HighsInfoPrimalSolutionStatus &Status of the primal solution\\
\HighsInt & \HighsInfoDualSolutionStatus &Status of the dual solution\\
\HighsInt & \HighsInfoBasisStatus &Status of the variable and constraint status information\\
\Double & \HighsInfoObjectiveFunctionValue &Objective function value\\
\Double & \HighsInfoMipDualBound &Dual bound from the MIP solover\\
\Double & \HighsInfoMipGap &Relative primal-dual gap from the MIP solover\\
\HighsInt & \HighsInfoNumPrimalInfeasibilities &Number of primal infeasibilities exceeding the tolerance\\
\Double & \HighsInfoMaxPrimalInfeasibility &Maximum primal infeasibility\\
\Double & \HighsInfoSumPrimalInfeasibilities &Sum of primal infeasibilities\\
\HighsInt & \HighsInfoNumDualInfeasibilities &Number of dual infeasibilities exceeding the tolerance\\
\Double & \HighsInfoMaxDualInfeasibility &Maximum dual infeasibility\\
\Double & \HighsInfoSumDualInfeasibilities &Sum of dual infeasibilities\\\hline
  \end{tabular}}
\caption{Members of the \HighsInfo{} class}\label{tab:HighsInfo}
\end{table}

\subsection{Solution values}
Solution values for the model are held by \HiGHS in an instance of the \HighsSolution{} structure. Its components are
listed in Table~\ref{tab:HighsSolution}.

In the \Cpp interface, a \Const{} reference to this instance of the
\HighsSolution{} structure is available, and a copy of the same data can
be obtained via the \C interface. When the objective sense is
switched, the dual optimality condition changes sign, and this is
reflected in the sign of the dual values.

The solution data that are available from \HiGHS depends on the value
of the model status, when it was identified, and how. To identify what
solution data are available, and whether the solution values are
feasible or not, consult the values of \HighsInfoPrimalSolutionStatus{}
and \HighsInfoDualSolutionStatus{} via \HighsInfo{} (Table~\ref{tab:HighsInfo}).

\begin{table}[ht]
\leftline{
  \begin{tabular}{|l|l|p{8cm}|}\hline
Type&Name&Description\\\hline
\VectorDouble & \HighsSolutionColValue & (Primal) solution values for columns (variables)\\
\VectorDouble & \HighsSolutionRowValue & (Primal) solution values for rows (constraints)\\
\VectorDouble & \HighsSolutionColDual & Dual values for columns\\
\VectorDouble & \HighsSolutionRowDual & Dual values for rows\\\hline
  \end{tabular}}
\caption{Members of the \HighsSolution{} structure}\label{tab:HighsSolution}
\end{table}

\subsection{The variable and constraint status}
The status of each variable and constraint is held by \HiGHS in an
instance of the \HighsBasis{} structure. In the case of LP problems,
this is the {\em basis}. Its main components are listed in
Table~\ref{tab:HighsBasis}.

The variable and constraint status data that are available from \HiGHS
depends on the value of the model status, when it was identified, and
how. To identify what variable and constraint status data are
available, consult the value of \HighsInfoBasisStatus{} via \HighsInfo{}
(Table~\ref{tab:HighsInfo}).

\begin{table}[ht]
\leftline{
  \begin{tabular}{|l|l|p{6cm}|}\hline
Type&Name&Description\\\hline
\VectorHighsBasisStatus & \HighsBasisColStatus & Status of the columns (variables)\\
\VectorHighsBasisStatus & \HighsBasisRowStatus & Status of the rows (constraints)\\\hline
  \end{tabular}}
\caption{Members of the \HighsBasis structure}\label{tab:HighsBasis}
\end{table}
The \HighsBasisStatus{} type is an \EnumClass, with members listed in
Table~\ref{tab:HighsBasisStatusEnumClass}, where the integer value
given is the cast used in the \C interface.  In the \Cpp interface, a
\Const{} reference to this instance of the \HighsBasis{} structure is
available, and a copy of the same data can be obtained via the \C
interface.

\begin{table}[ht]
  \leftline{
    \begin{tabular}{|l|r|p{5cm}|}\hline
      Name&Integer&Description\\\hline
\HighsBasisStatusLower & 0 & At lower bound or fixed value\\
\HighsBasisStatusBasic & 1 & Solved for (basic)\\
\HighsBasisStatusUpper & 2 & At upper bound\\
\HighsBasisStatusZero & 3 & Free and set to zero\\
\hline
  \end{tabular}}
  \caption{The \EnumClass{} type names for \HighsBasisStatus}\label{tab:HighsBasisStatusEnumClass}
\end{table}

\subsection{Methods}

\subsubsection{Solving the model}

The incumbent model is solved by calling the \Cpp method \HighsRun{} or,
in the \C interface, its equivalent method. Both are defined in
Table~\ref{tab:HighsRun}. By default, \HiGHS will use what it
considers to be the best solver of the appropriate type for the
incumbent model, and the best run-time option settings. To force
\HiGHS to solve with a particular solver and run-time options,
\HighsOptions{} values defined in Section~\ref{sect:Options} may be modified.

\begin{table}[ht]
\leftline{
  \begin{tabular}{|l|p{8cm}|}\hline
\Cpp \HiGHS class & \C interface equivalent\\\hline
\HighsRunDef& \CHighsRunDef\\\hline
  \end{tabular}}
\caption{Solving the incumbent model via the \Cpp and \C interface}\label{tab:HighsRun}
\end{table}

\subsubsection{Extracting the solution data}

After ``solving'' the model it is essential to inspect the model
status, since the model may have been found to be infeasible or
unbounded.

\begin{table}[ht]
\leftline{
  \begin{tabular}{l}
\HighsGetModelStatusDef\\
\HighsGetInfoDef\\
\HighsGetSolutionDef\\
\HighsGetBasisDef\\
  \end{tabular}}
\caption{Extracting the solution data via the \Cpp interface}\label{tab:SolutionDataCpp}
\end{table}

\begin{table}[ht]
\leftline{
  \begin{tabular}{lp{13cm}}
    \HighsInt{} \code{Highs\_getModelStatus(}&\VoidStarHighsInstance\code{);}
  \end{tabular}}

\leftline{
  \begin{tabular}{lp{13cm}}
    \HighsInt{} \code{Highs\_getScaledModelStatus(}&\VoidStarHighsInstance\code{);}
  \end{tabular}}

\leftline{
  \begin{tabular}{lp{13cm}}
    \HighsInt{} \code{Highs\_getIntInfoValue(}&\VoidStarHighsInstance\codeComma\Const{} \CharStar \HighsInfoName\codeComma \HighsIntStar{} \HighsInfoValue{} \code{);}\\
  \end{tabular}}
\caption{Extracting the solution data via the \C interface}\label{tab:SolutionDataC}
\end{table}

\section{Model extraction}\label{sect:ModelExtraction}

\section{Model modification}\label{sect:ModelModification}

\section{Other features}\label{sect:OtherFeatures}

\subsection{Hot start}\label{sect:HotStart}

\subsection{Presolve and postsolve}\label{sect:PresolvePostSolve}

\subsection{Ranging}\label{sect:Ranging}

\subsection{Basis solves}\label{sect:BasisSolves}

\subsection{Primal and dual rays}\label{sect:Rays}

\section{Options}\label{sect:Options}

\begin{itemize}
\item \Double \InfiniteCost
\item \Double \InfiniteBound
\item \Double \SmallMatrixValue
\item \Double \LargeMatrixValue
\item \Double \PrimalFeasibilityTolerance
\item \Double \DualFeasibilityTolerance
\item \Double \IpmOptimalityTolerance
\item \Double \ObjectiveBound
\item \Double \ObjectiveTarget
\item \HighsInt \HighsRandomSeed
\item \HighsInt \HighsDebugLevel
\item \HighsInt \HighsAnalysisLevel
\item \HighsInt \SimplexStrategy
\item \HighsInt \SimplexScaleStrategy
\item \HighsInt \SimplexCrashStrategy
\item \HighsInt \SimplexDualEdgeWeightStrategy
\item \HighsInt \SimplexPrimalEdgeWeightStrategy
\item \HighsInt \SimplexIterationLimit
\item \HighsInt \SimplexUpdateLimit
\item \HighsInt \IpmIterationLimit
\item \HighsInt \HighsMinThreads
\item \HighsInt \HighsMaxThreads
\item \String \SolutionFile
\item \String \LogFile
\item \Bool \WriteSolutionToFile
\item \Bool \WriteSolutionPretty
\item \Bool \OutputFlag
\item \Bool \LogToConsole
\item \HighsInt \LogDevLevel
\item \Bool \RunCrossover
\item \Bool \AllowUnboundedOrInfeasible
\item \Bool \UseImpliedBoundsFromPresolve
\item \Bool \MpsParserTypeFree
\item \HighsInt \KeepNRows
\item \HighsInt \AllowedSimplexMatrixScaleFactor
\item \HighsInt \AllowedSimplexCostScaleFactor
\item \HighsInt \SimplexDualiseStrategy
\item \HighsInt \SimplexPermuteStrategy
\item \Bool \DualSimplexCleanup
\item \HighsInt \SimplexPriceStrategy
\item \HighsInt \PresolveSubstitutionMaxfillin
\item \Bool \SimplexInitialConditionCheck
\item \Double \SimplexInitialConditionTolerance
\item \Double \DualSteepestEdgeWeightLogErrorThreshold
\item \Double \DualSimplexCostPerturbationMultiplier
\item \Double \PrimalSimplexBoundPerturbationMultiplier
\item \Double \PresolvePivotThreshold
\item \Double \FactorPivotThreshold
\item \Double \FactorPivotTolerance
\item \Double \StartCrossoverTolerance
\item \Bool \LessInfeasibleDseCheck
\item \Bool \LessInfeasibleDseChooseRow
\item \Bool \UseOriginalHfactorLogic
\item \HighsInt \MipMaxNodes
\item \HighsInt \MipMaxStallNodes
\item \HighsInt \MipMaxLeaves
\item \HighsInt \MipLpAgeLimit
\item \HighsInt \MipPoolAgeLimit
\item \HighsInt \MipPoolSoftLimit
\item \HighsInt \MipPscostMinreliable
\item \HighsInt \MipReportLevel
\item \Double \MipFeasibilityTolerance
\item \Double \MipEpsilon
\item \Double \MipHeuristicEffort
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{ref}


\end{document}

