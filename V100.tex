\documentclass[a4paper,12pt,twoside]{article}
\usepackage{xspace}
\usepackage{url}
\usepackage{relsize}
\usepackage{calc}
\usepackage{dimensions}
\usepackage{rotating}
\usepackage{colortbl}

\input Alias

\title{
\HiGHS Version 1.0.0}
\date{\today}
\author{J. A. J. Hall}

\flushbottom
\renewcommand{\familydefault}{\sfdefault}

\begin{document}

%\pagenumbering{roman}
\maketitle
\tableofcontents

\section{Introduction}
%
This document defines what \HiGHS can do, and how it can be run and
controlled externally. It does not describe the theory underlying the
optimzation methods that it uses, how they implemented, or how \HiGHS
is engineered internally. Mathematically, this document assumes no
more than familiarity with the definition of a linear programming (LP)
problem, and the fact that they can be solved with either the simplex
algorithm or interior point methods. Although \HiGHS can solve
mixed-integer programming (MIP) and quadratic programming (QP)
problems, users who have no interest in doing so can ingore references
to these problem classes.

\HiGHS was developed from the dual simplex solver of
Huangfu~\cite{HuHa13} by adding the interior point method solver (for
LP problems) of Schork~\cite{ScGo20}, the MIP solver of Gottwald, and
the convex QP solver of Feldmeier. Its presolve for LP and MIP was
written by Galabova and Gottwald, and its primal simplex solver was
written by Hall, based on work by Huangfu. Other features have been
written by Hall.

\HiGHS is mainly written in \Cpp with \OpenMP directives, but also has
some \C. The primary interface to \HiGHS is via \Cpp, but it also has full
interfaces for \C, \Csharp, \Fortran and \Python. There are also
third-party interfaces to \HiGHS from \Julia, \Rust and \Javascript.
This document describes the \Cpp interface and corresponding \C
interface methods. The other interfaces are analogous to the \C
interface.

\HiGHS uses \CMake as a build system and requires version 3.15. It has
been developed and tested on various Linux, MacOS and Windows
installations using both the GNU (\gpp) and Intel (\icc) \Cpp
compilers. Note that HiGHS requires (at least) version 4.9 of the GNU
compiler. If \OpenMP is unavailable to \HiGHS, then it will compile,
but will run in serial. \HiGHS has no third-party dependencies.

Although \HiGHS is freely available under the MIT license, we would be
pleased to learn about users' experience and give advice via email
sent to \HiGHSemail. If you use \HiGHS in an academic context, please
acknowledge this and cite the article of Huangfu and
Hall~\cite{HuHa13}, unless you make specific use of the interior point
method solver, in which case you should cite the work of Schork and
Gondzio~\cite{ScGo20}.

\subsection{Overview}

Sections~\ref{sect:ModelDefinition}-~\ref{sect:Options} set out what
\HiGHS can do and how it can be controlled. Section~\ref{sect:Methods}
documents the methods in the \Highs class (\Cpp) and corresponding
methods in the \C interface that are used to interact with \HiGHS.

Models are either passed to \HiGHS directly, or read from data
files. The definition of model data is set out in
Section~\ref{sect:ModelDefinition}. Section~\ref{sect:ModelSolution}
describes how \HiGHS is used to solve models, and how the resulting
solution data may be obtained. Models may be modified in ways set out
in Section~\ref{sect:ModelModification}, and other functionality
available within \HiGHS is covered in
Section~\ref{sect:OtherFeatures}. The parameters that control how
\HiGHS runs are referred to as \HighsOptions values or, more simply,
as ``options''. Their definition, default values and the means of
modifying them are defined in
Section~\ref{sect:Options}. Documentation of methods in the \Highs
class (\Cpp) and corresponding methods in the \C interface is in
Section~\ref{sect:Methods}.

For convenience,
Sections~\ref{sect:ModelDefinition}-~\ref{sect:Options} refer to the
\Cpp data structures used in \HiGHS. The \C interface involves simpler
items of data (scalar integer and double values, and pointers to
integer and double arrays), but is significantly more verbose. Data
items supplied to \HiGHS methods in the \C interface are used to
populate the \Cpp data structures. Data are returned from \HiGHS
methods as scalars or pointers into the \Cpp data structures that can
be interpreted as arrays.

\subsection{Long integers}
%
\input HighsInt

\subsection{Terminology}
%
The word ``vector'' is used to refer to the mathematical object in the
definition of a model. Within code, the corresponding data structure
is referred to as an array. The model within \HiGHS that has been
passed, read or built, and possibly modified, is referred to as the
``incumbent model''.

\subsection{Style}

For the \Cpp interface and, to an increasing extent internally, \HiGHS
now conforms to the Google \Cpp style guide~\cite{GoogleStyleGuide}.

\section{Model definition}\label{sect:ModelDefinition}
%
Models in \HiGHS are defined as an instance of the \HighsModel
class. This consists of one instance of the \HighsHessian class,
and one instance of the \HighsLp class. Communication of models
to and from \HiGHS is possible via instances of the \HighsLp or
\HighsModel class. In the \C and other interfaces, communication
of models is via scalar values and addresses of arrays.

\subsection{The \HighsLp class}\label{sect:HighsLp}
%

The \HighsLp class allows LP and MIP problems of the form
$$
\begin{array}{rl}
  \mathrm{minimize/maximize}&f+\bfc^T\bfx\\
  \mathrm{subject~to}&\bfL\le A\bfx\le \bfU\\
    &\bfl\le\bfx\le\bfu\\
  &\{x_i: i\in\SetI\}\in\Z
  \end{array}
$$
to be defined, and has the following members.
\begin{itemize}
\item \HighsInt \numCol: Number of columns (variables) $\bfx$ in the model
\item \HighsInt \numRow: Number of rows (constraints) in the model
\item \VectorHighsInt \Astart: Start of each vector of $A$ in the compressed sparse storage
\item \VectorHighsInt \Aindex: Indices of each vector of $A$ in the compressed sparse storage
\item \VectorDouble \Avalue: Values of each vector of $A$ in the compressed sparse storage
\item \VectorDouble \colCost: Cost (gradient) vector $\bfc$ in the objective function
\item \VectorDouble \colLower: Lower bounds $\bfl$ on the columns
\item \VectorDouble \colUpper: Upper bounds $\bfu$ on the columns
\item \VectorDouble \rowLower: Lower bounds $\bfL$ on the rows
\item \VectorDouble \rowUpper: Upper bounds $\bfU$ on the rows
\item \MatrixOrientation \orientation: Orientation of the constraint matrix
\item \ObjSense \sense: Sense of the objective: minimize or maximize
\item \Double \offset: Constant term $f$ in the objective function
\item \String \modelName: The name of the model
\item \VectorString \colName: The names of the columns
\item \VectorString \rowName: The names of the rows
\item \VectorHighsVarType \integrality: The set $\SetI$ of integrality restrictions on columns
\end{itemize}

Since \HiGHS is written in \Cpp and \C, all indexing begins from zero.
\subsubsection{Constraint matrix}
%
The constraint matrix $A$ is held using compressed sparse storage. Users
unfamiliar with this format should consult
Wikipedia~\cite{WikiSparseMatrix}. Since solvers generally access the
constraint matrix column-wise, this was originally the only
orientation permitted by \HiGHS. However, it is often preferable for
modelling interfaces and users to specify the constraint matrix
row-wise. The \orientation member of the \HighsLp
class is used to specify whether the matrix is held row-wise or
column-wise. If the orientation is not specified, it is assumed to be
\inred{???-wise}. In the \C interface, an \HighsInt parameter indicates
whether the matrix is \inred{row-wise (2) or column-wise (1)}.

If the constraint matrix $A$ is held column-wise (row-wise) then the
size of \Astart must be at least \numColPone (\numRowPone), the
zero'th entry of \Astart must be zero, and entry \numCol (\numRow) is
the number of entries in the arrays \Aindex and \Avalue. Other
requirements are discussed in
Section~\ref{sect:ConstraintMatrixValidation}.

\subsubsection{Objective function}
%
The sense of the objective (minimize or maximize) is defined by the
\sense member of the \HighsLp class. If the sense is not
specified, the objective is minimized. In the \C interface, an
\HighsInt parameter indicates whether the matrix is to be minimized
(1) or maximized (-1).

\subsubsection{Names}
%
When populating an instance of the \HighsLp class, no name data
needs to be supplied, and name data cannot be supplied via the \C
interface. The \modelName member of the \HighsLp class is the
name of the model, and is used occasionally in logging output. By
default it is an empty string. If the model is read from a data file,
then \modelName is the name of the file (less its extension). The
\colName and \rowName members of the \HighsLp class are, by
default, of zero size. If the model is read from an MPS data file,
then \colName and \rowName contain its column and row names. If names
are available they are printed when \HiGHS writes the model or
solution.

\subsubsection{Integrality}
%
The \integrality member of the \HighsLp class indicates which
variables (if any) must take integer values. If this member is of zero
size, or if all its entries are \code{HighsVarType::kContinuous}, the
set $\SetI$ is interpreted as being empty, so the instance is
interpreted as being an LP. If entries of \integrality are
\code{HighsVarType::kInteger} then, by default, the \HiGHS MIP solver
will be used to find the optimal integer values of the corresponding
variables. In the \C interface, an \HighsInt indicates whether a
particular variable is continuous (0) or must take an integer value
(1).

\subsection{The \HighsHessian class}\label{sect:HighsHessian}
%
The \HighsHessian class allows the \HighsModel class to
represent the Hessian matrix of the quadratic term in the objective
function that distinguishes QP problems from LP problems. The
representation of the Hessian matrix is column-wise, and
\HighsHessian class has the following members.

\begin{itemize}
\item \HighsInt \Qdim: Number of columns in the Hessian matrix
\item \VectorHighsInt \Qstart: Start of each column in the compressed sparse column storage
\item \VectorHighsInt \Qindex: Indices of each column in the compressed sparse column storage
\item \VectorDouble \Qvalue: Values of each column in the compressed sparse column storage
\end{itemize}

If a \HighsHessian instance has a positive value for \Qdim, and the
number of nonzeros in $Q$ is positive, then \Qdim must be equal to
\numCol. As with the column-wise constraint matrix, the size of
\Qstart must be at least \QdimPone, the zero'th entry of \Qstart must
be zero, and entry \Qdim is the number of entries in the arrays
\Qindex and \Qvalue. Other requirements are discussed in
Section~\ref{sect:HessianMatrixValidation}.

\subsection{Model validation}\label{sect:ModelValidation}

When \HiGHS obtains a new model, it is validated for correctness and
extreme data values. Control of the latter is determined by option
values.

\subsubsection{Constraint matrix validation}\label{sect:ConstraintMatrixValidation}

There is considerable scope for errors when defining a matrix in
compressed vector form. Thus, \HiGHS validates any such data supplied
to it. The zero'th entry of the \Astart array must be zero, and
entries must increase monotonically. This will not be strict if the
matrix contains zero vectors. The \Aindex entries corresponding to a
particular vector must be non-negative, must not be greater than or
equal to the (full) vector dimension, and there must be no duplicate
entries. If the data fails to satisfy any of these conditions, \HiGHS
will return an error.

There are limits on the minimum and maximum absolute values in the
constraint matrix that \HiGHS will use. These limits are
\HighsOptions values \SmallMatrixValue and
\LargeMatrixValue. Any entries below \SmallMatrixValue in absolute
value are ignored (with a warning) but entries found to be greater
than \LargeMatrixValue in absolute value will cause \HiGHS to return
with an error.

\subsubsection{Cost validation}\label{sect:CostValidation}

In \Cpp, if the size of \colCost is less than \numCol then \HiGHS
will return an error. Any entries found to be greater
than \InfiniteCost in absolute value will cause \HiGHS to return
with \inred{a warning or an error}.


\subsubsection{Bound validation}\label{sect:BoundValidation}

In \Cpp, if the size of \colLower or \colUpper is less than \numCol,
or if the size of \rowLower or \rowUpper is less than \numRow, then
\HiGHS will return an error. Any lower bound found to be greater than
or equal to \InfiniteBound, or any upper bound found to be less than
or equal to -\InfiniteBound, will cause \HiGHS to return with an error.

Bounds that are inconsistent due to the lower bound exceeding the
upper bound are permitted in \HiGHS but, when found, a warning message
will be issued. If \HiGHS is asked to solve a model with inconsistent
bounds, it will identify it as being infeasible.

Any lower bounds found to be less than or equal to -\InfiniteBound
will be ignored (treated as if they were negative infinity).  Any
upper bounds found to be greater than or equal to \InfiniteBound will
be ignored (treated as if they were positive infinity). \HiGHS will
report the number of bounds ignored in this way.

\subsubsection{Hessian matrix validation}\label{sect:HessianMatrixValidation}

An instance of the \HighsHessian class is validated for illegal
indexing in the same way as the constraint matrix. To discuss the
interpretation of the values in the instance, let $G$ be the
corresponding matrix. \HiGHS determines the matrix
$Q=\frac{1}{2}(G+G^T)$ and assesses its values the same way as the
constraint matrix, using the same option values for small and large
entries. If $Q$ is identically zero, then the \HighsHessian
instance is ignored, so the model will be solved as an LP. Otherwise,
$Q$ will be used as the quadratic term in the objective function.

As well as guaranteeing that the QP solver operates with a symmetric
Hessian matrix, this allows flexibility in the definition of the
Hessian matrix. If the original \HighsHessian instance
represents an entire symmetric matrix then, clearly, $Q=G$. However,
it may be convenient to for $G$ to be only the strictly upper
(equivalently lower) triangular portion of the Hessian, in which case
its strictly off-diagonal entries must be double the value in the
entire symmetric matrix.

The \HiGHS QP solver is for strictly convex problems: those with
positive definite Hessian. It will return with an error if it
identifies non-convexity. Since an {\em a priori\/} test of strict
convexity is a significant overhead, the only convexity test that is
performed is a check that all the diagonal entries of $Q$ are at least
\SmallMatrixValue.


\section{Model solution}\label{sect:ModelSolution}
%
When the incumbent model is solved, the solution data that is
available from \HiGHS comes from four sources: the model status, a set
of scalar information values, the solution of the model and the status
of each variable and constraint.

\subsection{The model status}
%
When the incumbent model is solved, \HiGHS will identify a model
status. In \Cpp this value is taken from an \code{enum class}
\HighsModelStatus, whose entries are listed in
Table~\ref{tab:HighsModelStatus}. The corresponding integer values
used in the \C interface are also listed.

\begin{table}
\centerline{
  \begin{tabular}{|l|l|p{8cm}|}\hline
Integer&\HighsModelStatus&Description\\\hline
0&\code{kNotset}&Not set\\
1&\code{kLoadError}&Error loading the model\\
2&\code{kModelError}&Error in the model definition\\
3&\code{kPresolveError}&Error presolving the model\\
4&\code{kSolveError}&Error solving the model\\
5&\code{kPostsolveError}&Error postsolving the model\\
6&\code{kModelEmpty}&Model is empty\\
7&\code{kOptimal}&Model solution is optimal\\
8&\code{kInfeasible}&Model is (primal) infeasible \\
9&\code{kUnboundedOrInfeasible}&Model is (primal) unbounded or infeasible\\
10&\code{kUnbounded}&Model is (primal) unbounded\\
11&\code{kObjectiveBound}&Any optimal objective is at least a given bound \\
12&\code{kObjectiveTarget}&There is a feasible solution with at least a given target value \\
13&\code{kTimeLimit}&The solution time limit has been reached\\
14&\code{kIterationLimit}&The solution iteration limit has been reached\\
15&\code{kUnknown}&The model status is unknown\\\hline
  \end{tabular}}
\caption{Model status values}\label{tab:HighsModelStatus}
\end{table}

\subsection{Scalar information}
%

\begin{itemize}
\item \LongInt \HighsInfoMipNodeCount: Number of MIP nodes created
\item \HighsInt \HighsInfoSimplexIterationCount: Cumulative number of simplex iterations performed
\item \HighsInt \HighsInfoIpmIterationCount: Cumulative number of interior point iterations performed
\item \HighsInt \HighsInfoCrossoverIterationCount: Cumulative number of crossover iterations performed
\item \HighsInt \HighsInfoQpIterationCount: Cumulative number of QP solver iterations performed
\item \HighsInt \HighsInfoPrimalSolutionStatus: Status of the primal solution
\item \HighsInt \HighsInfoDualSolutionStatus: Status of the dual solution
\item \Double \HighsInfoObjectiveFunctionValue: Objective function value
\item \Double \HighsInfoMipDualBound: Dual bound from the MIP solover
\item \Double \HighsInfoMipGap: Relative primal-dual gap from the MIP solover
\item \HighsInt \HighsInfoNumPrimalInfeasibilities: Number of primal infeasibilities exceeding the tolerance
\item \Double \HighsInfoMaxPrimalInfeasibility: Maximum primal infeasibility
\item \Double \HighsInfoSumPrimalInfeasibilities: Sum of primal infeasibilities
\item \HighsInt \HighsInfoNumDualInfeasibilities: Number of dual infeasibilities exceeding the tolerance
\item \Double \HighsInfoMaxDualInfeasibility: Maximum dual infeasibility
\item \Double \HighsInfoSumDualInfeasibilities: Sum of dual infeasibilities
\end{itemize}

\subsection{The model solution}
%

The \HighsSolution structure is used to extract the model solution from \HiGHS in the \Cpp interface. It has the following components
\begin{itemize}
\item \VectorDouble \HighsSolutionColValue: (Primal) solution values for columns (variables)
\item \VectorDouble \HighsSolutionRowValue: (Primal) solution values for rows (constraints)
\item \VectorDouble \HighsSolutionColDual: Dual values for columns
\item \VectorDouble \HighsSolutionRowDual: Dual values for rows
\end{itemize}
%
When the objective sense is switched, the dual optimality condition
changes sign, and this is reflected in the sign of the dual
values. The same data can be obtained via the \C interface.


\subsection{The variable and constraint status}
%
\begin{itemize}
\item \VectorHighsBasisStatus \HighsBasisColStatus: Status of the columns (variables)
\item \VectorHighsBasisStatus \HighsBasisRowStatus: Status of the rows (constraints)
\end{itemize}


The solution data that is available from \HiGHS depends on the value
of the model status, when it was identified, and how. If the model
status corresponds to an error, then no solution data are available. When \HiGHS solves a model, it first applies a presolve procedure with the aim of reducing the dimension of the problem to be solved directly. If the model is identified as being infeasible during t is possible that 

\section{Model modification}\label{sect:ModelModification}

\section{Other features}\label{sect:OtherFeatures}

\section{Options}\label{sect:Options}

\begin{itemize}
\item \Double \InfiniteCost
\item \Double \InfiniteBound
\item \Double \SmallMatrixValue
\item \Double \LargeMatrixValue
\item \Double \PrimalFeasibilityTolerance
\item \Double \DualFeasibilityTolerance
\item \Double \IpmOptimalityTolerance
\item \Double \ObjectiveBound
\item \Double \ObjectiveTarget
\item \HighsInt \HighsRandomSeed
\item \HighsInt \HighsDebugLevel
\item \HighsInt \HighsAnalysisLevel
\item \HighsInt \SimplexStrategy
\item \HighsInt \SimplexScaleStrategy
\item \HighsInt \SimplexCrashStrategy
\item \HighsInt \SimplexDualEdgeWeightStrategy
\item \HighsInt \SimplexPrimalEdgeWeightStrategy
\item \HighsInt \SimplexIterationLimit
\item \HighsInt \SimplexUpdateLimit
\item \HighsInt \IpmIterationLimit
\item \HighsInt \HighsMinThreads
\item \HighsInt \HighsMaxThreads
\item \String \SolutionFile
\item \String \LogFile
\item \Bool \WriteSolutionToFile
\item \Bool \WriteSolutionPretty
\item \Bool \OutputFlag
\item \Bool \LogToConsole
\item \HighsInt \LogDevLevel
\item \Bool \RunCrossover
\item \Bool \AllowUnboundedOrInfeasible
\item \Bool \UseImpliedBoundsFromPresolve
\item \Bool \MpsParserTypeFree
\item \HighsInt \KeepNRows
\item \HighsInt \AllowedSimplexMatrixScaleFactor
\item \HighsInt \AllowedSimplexCostScaleFactor
\item \HighsInt \SimplexDualiseStrategy
\item \HighsInt \SimplexPermuteStrategy
\item \Bool \DualSimplexCleanup
\item \HighsInt \SimplexPriceStrategy
\item \HighsInt \PresolveSubstitutionMaxfillin
\item \Bool \SimplexInitialConditionCheck
\item \Double \SimplexInitialConditionTolerance
\item \Double \DualSteepestEdgeWeightLogErrorThreshold
\item \Double \DualSimplexCostPerturbationMultiplier
\item \Double \PrimalSimplexBoundPerturbationMultiplier
\item \Double \PresolvePivotThreshold
\item \Double \FactorPivotThreshold
\item \Double \FactorPivotTolerance
\item \Double \StartCrossoverTolerance
\item \Bool \LessInfeasibleDseCheck
\item \Bool \LessInfeasibleDseChooseRow
\item \Bool \UseOriginalHfactorLogic
\item \HighsInt \MipMaxNodes
\item \HighsInt \MipMaxStallNodes
\item \HighsInt \MipMaxLeaves
\item \HighsInt \MipLpAgeLimit
\item \HighsInt \MipPoolAgeLimit
\item \HighsInt \MipPoolSoftLimit
\item \HighsInt \MipPscostMinreliable
\item \HighsInt \MipReportLevel
\item \Double \MipFeasibilityTolerance
\item \Double \MipEpsilon
\item \Double \MipHeuristicEffort
\end{itemize}

\section{Methods}\label{sect:Methods}

\bibliographystyle{abbrv}
\bibliography{ref}


\end{document}

