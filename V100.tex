\documentclass[a4paper,12pt,twoside]{article}
\usepackage{xspace}
\usepackage{url}
\usepackage{relsize}
\usepackage{calc}
\usepackage{dimensions}
\usepackage{rotating}
\usepackage{colortbl}
\usepackage{algpseudocode}
\usepackage{algorithm} 

\input Alias

\title{
\HiGHS Version 1.0.0}
\date{\today}
\author{\HighsEmail}

\flushbottom
\renewcommand{\familydefault}{\sfdefault}

\begin{document}

%\pagenumbering{roman}
\maketitle
\tableofcontents

\section{Introduction}
%
This document defines what \HiGHS can do, and how it can be run and
controlled externally. It does not describe the theory underlying the
optimzation methods that it uses, how they implemented, or how \HiGHS
is engineered internally. Mathematically, this document assumes no
more than familiarity with the definition of a linear programming (LP)
problem, and the fact that they can be solved with either the simplex
algorithm or interior point methods. Although \HiGHS can solve
mixed-integer programming (MIP) and quadratic programming (QP)
problems, users who have no interest in doing so can ingore references
to these problem classes.

\HiGHS was developed from the dual simplex solver of
Huangfu~\cite{HuHa13} by adding the interior point method solver (for
LP problems) of Schork~\cite{ScGo20}, the MIP solver of Gottwald, and
the convex QP solver of Feldmeier. Its presolve for LP and MIP was
written by Galabova and Gottwald, and its primal simplex solver was
written by Hall, based on work by Huangfu. Other features have been
written by Hall.

\HiGHS is mainly written in \Cpp with \OpenMP directives, but also has
some \C. The primary interface to \HiGHS is via \Cpp, but it also has full
interfaces for \C, \Csharp, \Fortran and \Python. There are also
third-party interfaces to \HiGHS from \Julia, \Rust and \Javascript.
This document describes the \Cpp interface and corresponding \C
interface methods. The other interfaces are analogous to the \C
interface.

\HiGHS uses \CMake as a build system and requires version 3.15. It has
been developed and tested on various Linux, MacOS and Windows
installations using both the GNU (\gpp) and Intel (\icc) \Cpp
compilers. Note that HiGHS requires (at least) version 4.9 of the GNU
compiler. If \OpenMP is unavailable to \HiGHS, then it will compile,
but will run in serial. \HiGHS has no third-party dependencies.

Although \HiGHS is freely available under the MIT license, we would be
pleased to learn about users' experience and give advice via email
sent to \HighsEmail. If you use \HiGHS in an academic context, please
acknowledge this and cite the article of Huangfu and
Hall~\cite{HuHa13}, unless you make specific use of the interior point
method solver, in which case you should cite the work of Schork and
Gondzio~\cite{ScGo20}.

\subsection{Overview}

Sections~\ref{sect:ModelDefinition}-~\ref{sect:Options} set out what
\HiGHS can do, the methods by which this is achieved, and the
parameters that control them. This is done by introducing the data
structures of \HiGHS that are used in the \Cpp interface, the methods
in the \Cpp interface, and the corresponding methods in the \C
interface. 

Models are either passed to \HiGHS directly, or read from data
files. The definition of the \HiGHS model data structure is set out in
Section~\ref{sect:ModelDefinition}, together with the methods for
model input and output in the \Cpp and \C
interfaces. Section~\ref{sect:ModelSolution} describes how \HiGHS is
used to solve models, and how the resulting solution data may be
obtained. Models may be modified in ways set out in
Section~\ref{sect:ModelModification}, and other functionality
available within \HiGHS is covered in
Section~\ref{sect:OtherFeatures}.

The parameters that control how \HiGHS runs are referred to option
values. Their definition, default values and the means of modifying
them are defined in Section~\ref{sect:Options}.

\subsection{Creating a \Highs instance}
%
In \Cpp, an instance of the \Highs class named (for example) \HighsInstance is created thus
\begin{itemize}
  \item[] \Highs \HighsInstance;
\end{itemize}
This requires the inclusion of the header file \HighsH.

In \C, an instance of \Highs is created and destroyed using the
methods defined in Table~\ref{tab:CHighsCreateDestroy}.
%
\begin{table}[ht]
\leftline{
  \begin{tabular}{p{15cm}}
    \CHighsCreateDef \\
    \CHighsDestroyDef
  \end{tabular}}
\caption{Creating and destroying a \Highs instance in \C using the methods \CHighsCreate and \CHighsDestroy}\label{tab:CHighsCreateDestroy}
\end{table}
%
So an instance named (for example) \HighsInstance is created and destroyed thus
\begin{itemize}
  \item[] \code{void* highs = \CHighsCreate;}
  \item[] \code{Highs\_destroy(highs);}
\end{itemize}
For all other methods in the \C interface, the first argument is the void pointer \HighsInstance.

\subsection{Long integers}
%
\input HighsInt

\subsection{Return values}
%
Most methods in the \Cpp and \C interfaces return a status to indicate
the success of the call. Those that do not are methods where model or
solution information is returned (and success can be assumed). The
type of the return status is \EnumClass \HighsStatus, with members
listed in Table~\ref{tab:HighsStatusEnumClass}, where the integer
value given is the cast used in the \C interface.

\input TableHighsStatusEnumClass

\subsection{Terminology}
%
The word ``vector'' is used to refer to the mathematical object in the
definition of a model. Within code, the corresponding data structure
is referred to as an array. The model within \HiGHS that has been
passed, read or built, and possibly modified, is referred to as the
``incumbent model''.

\subsection{Style}

For the \Cpp interface and, to an increasing extent internally, \HiGHS
now conforms to the Google \Cpp style guide~\cite{GoogleStyleGuide}.

\section{Model definition}\label{sect:ModelDefinition}
%
Models in \HiGHS are defined as an instance of the \HighsModel
class. This consists of one instance of the \HighsLp class,
and one instance of the \HighsHessian class. Communication of models
to and from \HiGHS is possible via instances of the \HighsLp or
\HighsModel class. In the \C and other interfaces, communication
of models is via scalar values and addresses of arrays.

\subsection{The \HighsLp class}\label{sect:HighsLp}
%

The \HighsLp class allows LP and MIP problems of the form
$$
\begin{array}{rl}
  \mathrm{minimize/maximize}&f+\bfc^T\bfx\\
  \mathrm{subject~to}&\bfL\le A\bfx\le \bfU\\
    &\bfl\le\bfx\le\bfu\\
  &\{x_i: i\in\SetI\}\in\Z
  \end{array}
$$
%
to be defined, and its members are defined in
Table~\ref{tab:HighsLp}. Since \HiGHS is written in \Cpp and \C, all
indexing begins from zero.

\begin{table}[ht]
\centerline{
  \begin{tabular}{|l|l|p{8cm}|}\hline
Type&Name&Description\\\hline
\HighsInt&\NumCol&Number of columns (variables) $\bfx$ in the model\\
\HighsInt&\NumRow&Number of rows (constraints) in the model\\
\VectorHighsInt&\Astart&Start of each vector of $A$ in the compressed sparse storage\\
\VectorHighsInt&\Aindex&Indices of each vector of $A$ in the compressed sparse storage\\
\VectorDouble&\Avalue&Values of each vector of $A$ in the compressed sparse storage\\
\VectorDouble&\ColCost&Cost (gradient) vector $\bfc$ in the objective function\\
\VectorDouble&\ColLower&Lower bounds $\bfl$ on the columns\\
\VectorDouble&\ColUpper&Upper bounds $\bfu$ on the columns\\
\VectorDouble&\RowLower&Lower bounds $\bfL$ on the rows\\
\VectorDouble&\RowUpper&Upper bounds $\bfU$ on the rows\\
\MatrixOrientation&\Orientation&Orientation of the constraint matrix\\
\ObjSense&\Sense&Sense of the objective: minimize or maximize\\
\Double&\Offset&Constant term $f$ in the objective function\\
\String&\ModelName&The name of the model\\
\VectorString&\ColName&The names of the columns\\
\VectorString&\RowName&The names of the rows\\
\VectorHighsVarType&\Integrality&The set $\SetI$ of integrality restrictions on columns\\\hline
  \end{tabular}}
\caption{\HighsLp class members}\label{tab:HighsLp}
\end{table}

Three members of the \HighsLp class (\Orientation, \Sense and
\Integrality) are of types particular to \HiGHS. They are all
\EnumClass, with members listed in Table~\ref{tab:HighsLpEnumClass},
where the integer value given is the cast used in the \C interface.

\begin{table}[ht]
  \centerline{
    \begin{tabular}{|l|r|p{8cm}|}\hline
      Name&Integer&Description\\\hline
      \MatrixOrientationNone&0&Undefined matrix orientation\\
      \MatrixOrientationColwise&1&Column-wise matrix orientation\\
      \MatrixOrientationRowwise&2&Row-wise matrix orientation\\\hline
      \ObjSenseMinimize&1&Optimization sense is minimize\\
      \ObjSenseMaximize&-1&Optimization sense is maximize\\\hline
      \HighsVarTypeContinuous&0&Variable can take continuous values\\
      \HighsVarTypeInteger&1&Variable must take integer values\\\hline
  \end{tabular}}
  \caption{The \EnumClass type names for \HighsLp class members}\label{tab:HighsLpEnumClass}
\end{table}
 
%
\subsubsection{Constraint matrix}
%
The constraint matrix $A$ is held using compressed sparse
storage. Users unfamiliar with this format should consult
Wikipedia~\cite{WikiSparseMatrix}. Since solvers generally access the
constraint matrix column-wise, this was originally the only
orientation permitted by \HiGHS. However, it is often preferable for
modelling interfaces and users to specify the constraint matrix
row-wise. The \Orientation member of the \HighsLp class is used to
specify whether the matrix is held row-wise or column-wise. When a
\HighsLp instance is created, the orientation is indicated as
undefined by being set to \MatrixOrientationNone. If the orientation
is not set to either \MatrixOrientationColwise or
\MatrixOrientationRowwise, \HiGHS returns an error. In the \C
interface, an \HighsInt parameter indicates whether the matrix is
row-wise or column-wise according to the integer values in
Table~\ref{tab:HighsLpEnumClass}.

If the constraint matrix $A$ is held column-wise (row-wise) then the
size of \Astart must be at least \NumColPone (\NumRowPone), the
zero'th entry of \Astart must be zero, and entry \NumCol (\NumRow) is
the number of entries in the arrays \Aindex and \Avalue. Other
requirements are discussed in
Section~\ref{sect:ConstraintMatrixValidation}.

\subsubsection{Objective function}
%
The sense of the objective (minimize or maximize) is defined by the
value of the \Sense member of the \HighsLp class. This is of type
\ObjSense, an \EnumClass whose names are given in
Table~\ref{tab:HighsLpEnumClass}. When a \HighsLp instance is created,
\Sense is set to \ObjSenseMinimize so, unless changed, the objective
is minimized. In the \C interface, an \HighsInt parameter indicates
whether the matrix is to be minimized or maximized according to the
integer values in Table~\ref{tab:HighsLpEnumClass}.

\subsubsection{Names}
%
When populating an instance of the \HighsLp class, no name data
needs to be supplied, and name data cannot be supplied via the \C
interface. The \ModelName member of the \HighsLp class is the
name of the model, and is used occasionally in logging output. By
default it is an empty string. If the model is read from a data file,
then \ModelName is the name of the file (less its extension). The
\ColName and \RowName members of the \HighsLp class are, by
default, of zero size. If the model is read from an MPS data file,
then \ColName and \RowName contain its column and row names. If names
are available they are printed when \HiGHS writes the model or
solution.

\subsubsection{Integrality}
%
The \Integrality member of the \HighsLp class indicates which
variables (if any) must take integer values. If this member is of zero
size, or if all its entries are \HighsVarTypeContinuous, the set
$\SetI$ is interpreted as being empty, so the instance is interpreted
as being an LP. If entries of \Integrality are \HighsVarTypeInteger
then, by default, the \HiGHS MIP solver will be used to find the
optimal integer values of the corresponding variables. In the \C
interface, an \HighsInt indicates whether a particular variable is
continuous or must take an integer value according to the integer
values in Table~\ref{tab:HighsLpEnumClass}.

\subsection{The \HighsHessian class}\label{sect:HighsHessian}
%
The \HighsHessian class allows the \HighsModel class to represent the
Hessian matrix of the quadratic term in the objective function that
distinguishes QP problems from LP problems. The representation of the
Hessian matrix is column-wise, and the \HighsHessian class members are
defined in Table~\ref{tab:HighsHessian}.

\begin{table}[ht]
\centerline{
  \begin{tabular}{|l|l|p{11cm}|}\hline
Type&Name&Description\\\hline
\HighsInt&\Qdim&Number of columns in the Hessian matrix\\
\VectorHighsInt&\Qstart&Start of each column in the compressed sparse column storage\\
\VectorHighsInt&\Qindex&Indices of each column in the compressed sparse column storage\\
\VectorDouble&\Qvalue&Values of each column in the compressed sparse column storage\\\hline
  \end{tabular}}
\caption{\HighsHessian class members}\label{tab:HighsHessian}
\end{table}

If a \HighsHessian instance has a positive value for \Qdim, and the
number of nonzeros in $Q$ is positive, then \Qdim must be equal to
\NumCol. As with the column-wise constraint matrix, the size of
\Qstart must be at least \QdimPone, the zero'th entry of \Qstart must
be zero, and entry \Qdim is the number of entries in the arrays
\Qindex and \Qvalue. Other requirements are discussed in
Section~\ref{sect:HessianMatrixValidation}.

\subsection{Model validation}\label{sect:ModelValidation}

When \HiGHS obtains a new model, it is validated for correctness and
extreme data values. Control of the latter is determined by option
values.

\subsubsection{Constraint matrix validation}\label{sect:ConstraintMatrixValidation}

There is considerable scope for errors when defining a matrix in
compressed vector form. Thus, \HiGHS validates any such data supplied
to it. The zero'th entry of the \Astart array must be zero, and
entries must increase monotonically. This will not be strict if the
matrix contains zero vectors. The \Aindex entries corresponding to a
particular vector must be non-negative, must not be greater than or
equal to the (full) vector dimension, and there must be no duplicate
entries. If the data fails to satisfy any of these conditions, \HiGHS
will return an error.

There are limits on the minimum and maximum absolute values in the
constraint matrix that \HiGHS will use. These limits are
\HighsOptions values \SmallMatrixValue and
\LargeMatrixValue. Any entries below \SmallMatrixValue in absolute
value are ignored (with a warning) but entries found to be greater
than \LargeMatrixValue in absolute value will cause \HiGHS to return
with an error.

\subsubsection{Cost validation}\label{sect:CostValidation}

In \Cpp, if the size of \ColCost is less than \NumCol then \HiGHS
will return an error. Any entries found to be greater
than \InfiniteCost in absolute value will cause \HiGHS to return
with \inred{a warning or an error}.


\subsubsection{Bound validation}\label{sect:BoundValidation}

In \Cpp, if the size of \ColLower or \ColUpper is less than \NumCol,
or if the size of \RowLower or \RowUpper is less than \NumRow, then
\HiGHS will return an error. Any lower bound found to be greater than
or equal to \InfiniteBound, or any upper bound found to be less than
or equal to -\InfiniteBound, will cause \HiGHS to return with an error.

Bounds that are inconsistent due to the lower bound exceeding the
upper bound are permitted in \HiGHS but, when found, a warning message
will be issued. If \HiGHS is asked to solve a model with inconsistent
bounds, it will identify it as being infeasible.

Any lower bounds found to be less than or equal to -\InfiniteBound
will be ignored (treated as if they were negative infinity).  Any
upper bounds found to be greater than or equal to \InfiniteBound will
be ignored (treated as if they were positive infinity). \HiGHS will
report the number of bounds ignored in this way.

\subsubsection{Hessian matrix validation}\label{sect:HessianMatrixValidation}

An instance of the \HighsHessian class is validated for illegal
indexing in the same way as the constraint matrix. To discuss the
interpretation of the values in the instance, let $G$ be the
corresponding matrix. \HiGHS determines the matrix
$Q=\frac{1}{2}(G+G^T)$ and assesses its values the same way as the
constraint matrix, using the same option values for small and large
entries. If $Q$ is identically zero, then the \HighsHessian
instance is ignored, so the model will be solved as an LP. Otherwise,
$Q$ will be used as the quadratic term in the objective function.

As well as guaranteeing that the QP solver operates with a symmetric
Hessian matrix, this allows flexibility in the definition of the
Hessian matrix. If the original \HighsHessian instance
represents an entire symmetric matrix then, clearly, $Q=G$. However,
it may be convenient to for $G$ to be only the strictly upper
(equivalently lower) triangular portion of the Hessian, in which case
its strictly off-diagonal entries must be double the value in the
entire symmetric matrix.

The \HiGHS QP solver is for strictly convex problems: those with
positive definite Hessian. It will return with an error if it
identifies non-convexity. Since an {\em a priori\/} test of strict
convexity is a significant overhead, the only convexity test that is
performed is a check that all the diagonal entries of $Q$ are at least
\SmallMatrixValue.

\subsection{Methods}\label{sect:ModelDefinitionMethods}

In \Cpp, the model is passed to \HiGHS by creating an instance of the
\HighsModel class (or using a \HighsLp instance if the model of
interest is only an LP or MIP), populating its data, and passing it to
\HiGHS using \HighsPassModel as defined in
Table~\ref{tab:HighsPassModel}.
%
\begin{table}[ht]
\centerline{
  \begin{tabular}{p{15cm}}
    \HighsPassModelModelDef \\
    \HighsPassModelLpDef 
  \end{tabular}}
\caption{Passing a \HighsModel or \HighsLp to \Highs in \Cpp}\label{tab:HighsPassModel}
\end{table}
%
The forms of the argument to \HighsPassModel are defined so that
maximum memory efficiency can be achieved by passing the \HighsModel
or \HighsLp instance via \code{std::move}. For example, suppose that
the user's \HighsModel instance is called \code{model}. Calling
\code{passModel(std::move(model))} ensures that the array content of
the user's \HighsModel instance is moved to the \HighsModel instance
of the incumbent model in \Highs without creating an additional copy
at any stage. A consequence of this approach is that, on return from
\HighsPassModel, the user's \HighsModel instance has no array
content.

In the \C interface, the components of a \HighsModel or \HighsLp
instance are passed as indivdual scalars or pointers. The methods for
an LP, MIP or general model are defined in
Table~\ref{tab:CHighsPassModel}, where the parameter names are
arbitrary. However, for comparison, the names of the corresponding
class members are used.
%
\begin{table}[ht]
\leftline{
  \begin{tabular}{lp{13cm}}
    \HighsInt \code{Highs\_passLp(}&
    \VoidStar \HighsInstance,\\
    &\Const \HighsInt \NumCol,
    \Const \HighsInt \NumRow,\\
    &\Const \HighsInt \NumNz,\\
    &\Const \HighsInt \Orientation,
    \Const \HighsInt \Sense,\\
    &\Const \Double \Offset,\\
    &\Const \DoubleStar \ColCost,
    \Const \DoubleStar \ColLower,\\
    &\Const \DoubleStar \ColUpper,
    \Const \DoubleStar \RowLower,\\
    &\Const \DoubleStar \RowUpper,
    \Const \HighsIntStar \Astart,\\
    &\Const \HighsIntStar \Aindex,
    \Const \DoubleStar \Avalue,
    \code{);} \\\noalign{\medskip}
    \HighsInt \code{Highs\_passMip(}&
    \VoidStar \HighsInstance,\\
    &\Const \HighsInt \NumCol,
    \Const \HighsInt \NumRow,\\
    &\Const \HighsInt \NumNz,\\
    &\Const \HighsInt \Orientation,
    \Const \HighsInt \Sense,\\
    &\Const \Double \Offset,\\
    &\Const \DoubleStar \ColCost,
    \Const \DoubleStar \ColLower,\\
    &\Const \DoubleStar \ColUpper,
    \Const \DoubleStar \RowLower,\\
    &\Const \DoubleStar \RowUpper,
    \Const \HighsIntStar \Astart,\\
    &\Const \HighsIntStar \Aindex,
    \Const \DoubleStar \Avalue,\\
    &\Const \HighsIntStar \Integrality
    \code{);} \\\noalign{\medskip}
    \HighsInt \code{Highs\_passModel(}&
    \VoidStar \HighsInstance,\\
    &\Const \HighsInt \NumCol,
    \Const \HighsInt \NumRow,\\
    &\Const \HighsInt \NumNz,
    \Const \HighsInt \HessianNumNz,\\
    &\Const \HighsInt \Orientation,
    \Const \HighsInt \Sense,\\
    &\Const \Double \Offset,\\
    &\Const \DoubleStar \ColCost,
    \Const \DoubleStar \ColLower,\\
    &\Const \DoubleStar \ColUpper,
    \Const \DoubleStar \RowLower,\\
    &\Const \DoubleStar \RowUpper,
    \Const \HighsIntStar \Astart,\\
    &\Const \HighsIntStar \Aindex,
    \Const \DoubleStar \Avalue,\\
    &\Const \HighsIntStar \Qstart,
    \Const \HighsIntStar \Qindex,\\
    &\Const \DoubleStar \Qvalue,\\
    &\Const \HighsIntStar \Integrality
    \code{);}
  \end{tabular}}
\caption{Passing data for a \HighsModel or \HighsLp to \Highs in \C}\label{tab:CHighsPassModel}
\end{table}
%

\section{Model solution}\label{sect:ModelSolution}
%
When the incumbent model is solved, the solution data that is
available from \HiGHS comes from four sources: the model status, a set
of scalar information values, the solution of the model and the status
of each variable and constraint.

\subsection{The model status}
%
When the incumbent model is solved, \HiGHS will identify a model
status. In \Cpp this value is taken from an \code{enum class}
\HighsModelStatus, whose entries are listed in
Table~\ref{tab:HighsModelStatus}. The corresponding integer values
used in the \C interface are also listed.

\begin{table}[ht]
\centerline{
  \begin{tabular}{|r|l|p{10cm}|}\hline
Integer&\HighsModelStatus&Description\\\hline
0&\code{kNotset}&Not set\\
1&\code{kLoadError}&Error loading the model\\
2&\code{kModelError}&Error in the model definition\\
3&\code{kPresolveError}&Error presolving the model\\
4&\code{kSolveError}&Error solving the model\\
5&\code{kPostsolveError}&Error postsolving the model\\
6&\code{kModelEmpty}&Model is empty\\
7&\code{kOptimal}&Model solution is optimal\\
8&\code{kInfeasible}&Model is (primal) infeasible \\
9&\code{kUnboundedOrInfeasible}&Model is (primal) unbounded or infeasible\\
10&\code{kUnbounded}&Model is (primal) unbounded\\
11&\code{kObjectiveBound}&Any optimal objective is at least a given bound \\
12&\code{kObjectiveTarget}&There is a feasible solution with at least a given target value \\
13&\code{kTimeLimit}&The solution time limit has been reached\\
14&\code{kIterationLimit}&The solution iteration limit has been reached\\
15&\code{kUnknown}&The model status is unknown\\\hline
  \end{tabular}}
\caption{Model status values}\label{tab:HighsModelStatus}
\end{table}

\subsection{Scalar information}
%
Scalar information about the solution of the model is held by \HiGHS
in an instance of the \HighsInfo class. The members of this class are
listed in Table~\ref{tab:HighsInfo}. The truth of \HighsInfoValid
indicates whether the values of the remaining members are valid. In
the \Cpp interface, a \Const reference to this instance of the \HighsInfo
class is available. Values of individual members can also be obtained,
and this is how they are in the \C interface.
\begin{table}[ht]
\centerline{
  \begin{tabular}{|l|l|p{10cm}|}\hline
Type&Name&Description\\\hline
\Bool & \HighsInfoValid &Validity of the data in the class instance\\
\LongInt & \HighsInfoMipNodeCount &Number of MIP nodes created\\
\HighsInt & \HighsInfoSimplexIterationCount &Cumulative number of simplex iterations performed\\
\HighsInt & \HighsInfoIpmIterationCount &Cumulative number of interior point iterations performed\\
\HighsInt & \HighsInfoCrossoverIterationCount &Cumulative number of crossover iterations performed\\
\HighsInt & \HighsInfoQpIterationCount &Cumulative number of QP solver iterations performed\\
\HighsInt & \HighsInfoPrimalSolutionStatus &Status of the primal solution\\
\HighsInt & \HighsInfoDualSolutionStatus &Status of the dual solution\\
\HighsInt & \HighsInfoBasisStatus &Status of the variable and constraint status information\\
\Double & \HighsInfoObjectiveFunctionValue &Objective function value\\
\Double & \HighsInfoMipDualBound &Dual bound from the MIP solover\\
\Double & \HighsInfoMipGap &Relative primal-dual gap from the MIP solover\\
\HighsInt & \HighsInfoNumPrimalInfeasibilities &Number of primal infeasibilities exceeding the tolerance\\
\Double & \HighsInfoMaxPrimalInfeasibility &Maximum primal infeasibility\\
\Double & \HighsInfoSumPrimalInfeasibilities &Sum of primal infeasibilities\\
\HighsInt & \HighsInfoNumDualInfeasibilities &Number of dual infeasibilities exceeding the tolerance\\
\Double & \HighsInfoMaxDualInfeasibility &Maximum dual infeasibility\\
\Double & \HighsInfoSumDualInfeasibilities &Sum of dual infeasibilities\\\hline
  \end{tabular}}
\caption{Members of the \HighsInfo class}\label{tab:HighsInfo}
\end{table}
%
The values of \HighsInfoPrimalSolutionStatus and
\HighsInfoDualSolutionStatus indicate the nature of the solution
values that are available. Valid values for the primal or dual
infeasiblility data are naturally non-negative. Thus a negative value
indicates that the data are not available.

Methods in ihe \Cpp interface allows values of individual members to
be obtained, and it is via correponding methods in the \C interface
that these information values are obtained.

\subsection{Solution values}
%
Solution values for the model are held by \HiGHS in an instance of the \HighsSolution structure. Its components are
listed in Table~\ref{tab:HighsSolution}
\begin{table}[ht]
\centerline{
  \begin{tabular}{|l|l|p{10cm}|}\hline
Type&Name&Description\\\hline
\VectorDouble & \HighsSolutionColValue & (Primal) solution values for columns (variables)\\
\VectorDouble & \HighsSolutionRowValue & (Primal) solution values for rows (constraints)\\
\VectorDouble & \HighsSolutionColDual & Dual values for columns\\
\VectorDouble & \HighsSolutionRowDual & Dual values for rows\\\hline
  \end{tabular}}
\caption{Members of the \HighsSolution structure}\label{tab:HighsSolution}
\end{table}
%
In the \Cpp interface, a \Const reference to this instance of the
\HighsSolution structure is available, and a copy of the same data can
be obtained via the \C interface. When the objective sense is
switched, the dual optimality condition changes sign, and this is
reflected in the sign of the dual values.

The solution data that are available from \HiGHS depends on the value
of the model status, when it was identified, and how. To identify what
solution data are available, and whether the solution values are
feasible or not, consult the values of \HighsInfoPrimalSolutionStatus
and \HighsInfoDualSolutionStatus.

\subsection{The variable and constraint status}
%
The status of each variable and constraint is held by \HiGHS in an
instance of the \HighsBasis structure. In the case of LP problems,
this is the {\em basis}. Its main components are listed in
Table~\ref{tab:HighsBasis}
\begin{table}[ht]
\centerline{
  \begin{tabular}{|l|l|p{10cm}|}\hline
Type&Name&Description\\\hline
\VectorHighsBasisStatus & \HighsBasisColStatus & Status of the columns (variables)\\
\VectorHighsBasisStatus & \HighsBasisRowStatus & Status of the rows (constraints)\\\hline
  \end{tabular}}
\caption{Members of the \HighsBasis structure}\label{tab:HighsBasis}
\end{table}
%
The \HighsBasisStatus type is an \EnumClass, with members
listed in Table~\ref{tab:HighsBasisStatusEnumClass}, where the integer
value given is the cast used in the \C interface.
In the \Cpp interface, a \Const reference to this instance of the
\HighsBasis structure is available, and a copy of the same data can be obtained
via the \C interface.

\begin{table}[ht]
  \centerline{
    \begin{tabular}{|l|r|p{11cm}|}\hline
      Name&Integer&Description\\\hline
\HighsBasisStatusLower & 0 & At lower bound or fixed value\\
\HighsBasisStatusBasic & 1 & Solved for (basic)\\
\HighsBasisStatusUpper & 2 & At upper bound\\
\HighsBasisStatusZero & 3 & Free and set to zero\\\hline
\hline
  \end{tabular}}
  \caption{The \EnumClass type names for \HighsBasisStatus}\label{tab:HighsBasisStatusEnumClass}
\end{table}

The variable and constraint status data that are available from \HiGHS depends on the value
of the model status, when it was identified, and how. To identify what
variable and constraint status data are available, consult the value of \HighsInfoBasisStatus.

\subsection{Methods}

The incumbent model is solved by calling the \Cpp method
\begin{itemize}
\item \HighsRunDef
\end{itemize}
The corresponding method in the \C interface is
\begin{itemize}
\item \CHighsRunDef
\end{itemize}
%
By default, \Highs will use what it considers to be the best solver of
the appropriate type for the incumbent model, and the best run-time
option settings. To force \Highs to solve with a particular solver and
run-time options, \HighsOptions values in Section~\ref{sect:Options} may
be modified.

\section{Model modification}\label{sect:ModelModification}

\section{Other features}\label{sect:OtherFeatures}

\section{Options}\label{sect:Options}

\begin{itemize}
\item \Double \InfiniteCost
\item \Double \InfiniteBound
\item \Double \SmallMatrixValue
\item \Double \LargeMatrixValue
\item \Double \PrimalFeasibilityTolerance
\item \Double \DualFeasibilityTolerance
\item \Double \IpmOptimalityTolerance
\item \Double \ObjectiveBound
\item \Double \ObjectiveTarget
\item \HighsInt \HighsRandomSeed
\item \HighsInt \HighsDebugLevel
\item \HighsInt \HighsAnalysisLevel
\item \HighsInt \SimplexStrategy
\item \HighsInt \SimplexScaleStrategy
\item \HighsInt \SimplexCrashStrategy
\item \HighsInt \SimplexDualEdgeWeightStrategy
\item \HighsInt \SimplexPrimalEdgeWeightStrategy
\item \HighsInt \SimplexIterationLimit
\item \HighsInt \SimplexUpdateLimit
\item \HighsInt \IpmIterationLimit
\item \HighsInt \HighsMinThreads
\item \HighsInt \HighsMaxThreads
\item \String \SolutionFile
\item \String \LogFile
\item \Bool \WriteSolutionToFile
\item \Bool \WriteSolutionPretty
\item \Bool \OutputFlag
\item \Bool \LogToConsole
\item \HighsInt \LogDevLevel
\item \Bool \RunCrossover
\item \Bool \AllowUnboundedOrInfeasible
\item \Bool \UseImpliedBoundsFromPresolve
\item \Bool \MpsParserTypeFree
\item \HighsInt \KeepNRows
\item \HighsInt \AllowedSimplexMatrixScaleFactor
\item \HighsInt \AllowedSimplexCostScaleFactor
\item \HighsInt \SimplexDualiseStrategy
\item \HighsInt \SimplexPermuteStrategy
\item \Bool \DualSimplexCleanup
\item \HighsInt \SimplexPriceStrategy
\item \HighsInt \PresolveSubstitutionMaxfillin
\item \Bool \SimplexInitialConditionCheck
\item \Double \SimplexInitialConditionTolerance
\item \Double \DualSteepestEdgeWeightLogErrorThreshold
\item \Double \DualSimplexCostPerturbationMultiplier
\item \Double \PrimalSimplexBoundPerturbationMultiplier
\item \Double \PresolvePivotThreshold
\item \Double \FactorPivotThreshold
\item \Double \FactorPivotTolerance
\item \Double \StartCrossoverTolerance
\item \Bool \LessInfeasibleDseCheck
\item \Bool \LessInfeasibleDseChooseRow
\item \Bool \UseOriginalHfactorLogic
\item \HighsInt \MipMaxNodes
\item \HighsInt \MipMaxStallNodes
\item \HighsInt \MipMaxLeaves
\item \HighsInt \MipLpAgeLimit
\item \HighsInt \MipPoolAgeLimit
\item \HighsInt \MipPoolSoftLimit
\item \HighsInt \MipPscostMinreliable
\item \HighsInt \MipReportLevel
\item \Double \MipFeasibilityTolerance
\item \Double \MipEpsilon
\item \Double \MipHeuristicEffort
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{ref}


\end{document}

